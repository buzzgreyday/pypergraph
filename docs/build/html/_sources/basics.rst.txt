Basics
======

Account/Wallet
______________

In Pypergraph wallets are referred to as accounts.

* **CREATE NEW DAG ACCOUNT**

.. code-block:: python

    from pypergraph.dag_keystore import KeyStore
    from pypergraph.dag_account import DagAccount

    keystore = KeyStore()

    mnemonic = keystore.get_mnemonic()
    seed_phrase = mnemonic.get("words")
    account = DagAccount()
    account.login_with_seed_phrase(words=seed_phrase)

.. dropdown:: Login variations
    :animate: fade-in

    After creating the account object this can be used to login and interacting with the Constellation APIs.

    1. Login with seed phrase:

    .. code-block:: python

        account.login_with_seed_phrase(
            "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon"
        )

    2. Login with private key:

    .. code-block:: python

            account.login_with_private_key("your_private_key_here")

    3. Login with public key (private key is needed to send transactions, etc.):

    .. code-block:: python

            account.login_with_public_key("your_public_key_here")


* **CREATE DAG ACCOUNT FROM EXISTING SECRET**

.. code-block:: python

    seed_phrase = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon"
    account = pypergraph.dag_account.DagAccount()
    account.login_with_seed_phrase(words=seed_phrase)

.. code-block:: python

    private_key = "this01is02A03Fake04PRIVATE05key06"
    account = pypergraph.dag_account.DagAccount()
    account.login_with_private_key(private_key=private_key)

* **SEND CURRENCY TRANSACTION**

.. code-block:: python

    # Create an account and login
    seed_phrase = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon"
    account = pypergraph.dag_account.DagAccount()
    account.login_with_seed_phrase(words=seed_phrase)
    # Generate signed transaction
    tx, hash_ = await account.generate_signed_transaction(
        to_address="DAG2this01is02A03FAKE04DAG05Address06",
        amount=100000000,
        fee=200000
    )
    # Send transaction
    await account.network.post_transaction(tx)

.. code-block:: python

    # Create an account and login
    seed_phrase = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon"
    account = pypergraph.dag_account.DagAccount()
    account.login_with_seed_phrase(words=seed_phrase)
    # Change network to "testnet", "integrationnet" or "mainnet"
    account.connect(network_id="testnet")
    # Generate signed transaction
    tx, hash_ = await account.generate_signed_transaction(
        to_address="DAG2this01is02A03FAKE04DAG05Address06",
        amount=100000000,
        fee=200000
    )
    # Send transaction
    await account.network.post_transaction(tx)

.. dropdown:: Connect parameters
    :animate: fade-in

    Placeholder

.. code-block:: python

    # Create account and login
    seed_phrase = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon"
    account = pypergraph.dag_account.DagAccount()
    account.login_with_seed_phrase(words=seed_phrase)
    # Create a Metagraph client to interact with Metagraphs
    account_metagraph_client = pypergraph.dag_account.MetagraphTokenClient(
        account=account,
        metagraph_id="DAG7ChnhUF7uKgn8tXy45aj4zn9AFuhaZr8VXY43",
        l0_host="http://elpaca-l0-2006678808.us-west-1.elb.amazonaws.com:9100",
        cl1_host="http://elpaca-cl1-1512652691.us-west-1.elb.amazonaws.com:9200"
    )
    last_ref = await account_metagraph_client.network.get_address_last_accepted_transaction_ref(
        address=from_address
    )
    tx, hash_ = await account_metagraph_client.account.generate_signed_transaction(
        to_address=to_address,
        amount=100000000,
        fee=0,
        last_ref=last_ref
    )
    # Send transaction
    await account_metagraph_client.network.post_transaction(
        tx=tx
    )

.. dropdown:: Metagraph client parameters
    :animate: fade-in

    Placeholder

* **POST DATA TO METAGRAPH**

.. code-block:: python

    tx = {
        "CreatePoll": {
            "name": 'test_poll',
            "owner": f'{from_address}',
            "pollOptions": [ 'true', 'false' ],
            "startSnapshotOrdinal": 1000, #start_snapshot, you should replace
            "endSnapshotOrdinal": 100000 #end_snapshot, you should replace
        }
    }
    seed_phrase = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon"
    account = pypergraph.dag_account.DagAccount()
    account.login_with_seed_phrase(seed_phrase)
    account_metagraph_client = pypergraph.dag_account.MetagraphTokenClient(
        account=account,
        metagraph_id="DAG6DOES00NOT00MATTER00HERE",
        l0_host="http://localhost:9200",
        cl1_host="http://localhost:9300",
        dl1_host="http://localhost:9300"
    )

    keystore = KeyStore()
    private_key = keystore.get_private_key_from_mnemonic(phrase=mnemo)
    public_key = account_metagraph_client.account.public_key[2:]  # Remove '04' prefix
    signature, hash_ = keystore.data_sign(
            private_key=private_key, msg=msg, prefix=False, encoding="hex"
        )

    proof = {
        "id": public_key,
        "signature": signature
    }
    tx = {
        "value": tx,
        "proofs": [proof]
    }
    r = await account_metagraph_client.network.post_data(tx)

.. dropdown:: Data signing parameters
    :animate: fade-in

    Encode message according to serializeUpdate on your template module l1.

    * **Prefix**: :bdg-primary:`True` or :bdg-primary:`False`

    If parameter is unset, **default** is :bdg-primary:`True`. If :bdg-primary:`True` `"\u0019Constellation Signed Data:\n"` is added to the encoded transaction before signing.

    * **Encoding**: :bdg-primary:`hex` or :bdg-primary:`base64` or a custom `callable` :bdg-primary:`function`.

    If parameter is unset, **default** is :bdg-primary:`hex`. :bdg-primary:`base64` will encode the transaction using :bdg-primary:`base64` before signing. If a custom encoding method is wanted, this can be injected, e.g.:

    .. code-block:: python

        tx = {
            "CreatePoll": {
                "name": 'test_poll',
                "owner": f'{from_address}',
                "pollOptions": [ 'true', 'false' ],
                "startSnapshotOrdinal": 1000, #start_snapshot, you should replace
                "endSnapshotOrdinal": 100000 #end_snapshot, you should replace
            }
        }

        def encode(tx: dict) -> str:
            encoded_tx = json.dumps(msg, separators=(',', ':'))
            return base64.b64encode(encoded.encode()).decode()

        signature, hash_ = keystore.data_sign(
            private_key=private_key,
            msg=tx,
            prefix=False,
            encoding=encode
        )


